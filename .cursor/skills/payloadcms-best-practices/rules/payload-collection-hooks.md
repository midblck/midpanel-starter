# payload-collection-hooks

Use PayloadCMS collection hooks for business logic, data transformation, and side effects in a maintainable and testable way.

## Why It Matters

Collection hooks provide:
- Centralized business logic
- Data validation and transformation
- Audit trails and logging
- Integration with external services
- Automatic side effects (notifications, cache invalidation)
- Better separation of concerns

## Incorrect Example

```typescript
// ❌ Bad: Business logic scattered in API routes
// pages/api/posts/[id].ts
export async function PUT(request: Request, { params }) {
  const { id } = params
  const data = await request.json()

  // Business logic mixed with API logic
  if (data.status === 'published') {
    // Send notification
    await sendNotification(data.author, 'Post published')

    // Update search index
    await updateSearchIndex(id, data)

    // Clear cache
    await clearPostCache(id)
  }

  // Update database
  const payload = await getPayload({ config: configPromise })
  const post = await payload.update({
    collection: 'posts',
    id,
    data,
  })

  return Response.json({ post })
}

// ❌ Bad: No validation or transformation
export const Posts: CollectionConfig = {
  slug: 'posts',
  fields: [
    { name: 'title', type: 'text' },
    { name: 'content', type: 'richText' },
    { name: 'status', type: 'select', options: ['draft', 'published'] },
  ],
  // No hooks for business logic
}
```

## Correct Example

```typescript
// ✅ CORRECT: Business logic in collection hooks
export const Posts: CollectionConfig = {
  slug: 'posts',
  fields: [
    { name: 'title', type: 'text', required: true },
    { name: 'content', type: 'richText', required: true },
    {
      name: 'status',
      type: 'select',
      options: ['draft', 'published', 'archived'],
      defaultValue: 'draft',
    },
    {
      name: 'publishedAt',
      type: 'date',
      admin: {
        readOnly: true, // Set by hook
      },
    },
    {
      name: 'slug',
      type: 'text',
      unique: true,
      admin: {
        readOnly: true, // Generated by hook
      },
    },
  ],
  hooks: {
    // Data transformation before saving
    beforeChange: [
      async ({ data, operation }) => {
        // Generate slug from title
        if (data.title && !data.slug) {
          data.slug = data.title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/(^-|-$)/g, '')
        }

        // Set published date when publishing
        if (data.status === 'published' && !data.publishedAt) {
          data.publishedAt = new Date().toISOString()
        }

        // Sanitize content
        if (data.content) {
          data.content = sanitizeRichText(data.content)
        }

        return data
      },
    ],

    // Side effects after saving
    afterChange: [
      async ({ doc, operation, previousDoc }) => {
        // Send notifications for published posts
        if (doc.status === 'published' && previousDoc?.status !== 'published') {
          await sendNotification(doc.author, 'Post published', doc)
        }

        // Update search index
        await updateSearchIndex(doc.id, doc)

        // Clear relevant caches
        await clearPostCache(doc.id)
        if (doc.slug !== previousDoc?.slug) {
          await clearPostCache(previousDoc.slug)
        }
      },
    ],

    // Validation before operations
    beforeRead: [
      async ({ doc }) => {
        // Add computed fields
        if (doc) {
          doc.readTime = calculateReadTime(doc.content)
          doc.wordCount = countWords(doc.content)
        }
        return doc
      },
    ],

    // Access control validation
    beforeDelete: [
      async ({ req, doc }) => {
        // Prevent deletion of published posts by non-admins
        if (doc.status === 'published' && req.user?.role !== 'admin') {
          throw new Error('Cannot delete published posts')
        }
      },
    ],
  },
}

// ✅ CORRECT: Hook utilities for reusability
// lib/hooks/post-hooks.ts
export const generateSlug = ({ data }: BeforeChangeHookArgs) => {
  if (data.title && !data.slug) {
    data.slug = data.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '')
  }
  return data
}

export const handlePublishing = async ({ data, doc }: AfterChangeHookArgs) => {
  if (data.status === 'published' && doc) {
    await sendNotification(doc.author, 'Post published')
    await updateSearchIndex(doc.id, doc)
  }
}

// Usage in collection
export const Posts: CollectionConfig = {
  slug: 'posts',
  // ... fields
  hooks: {
    beforeChange: [generateSlug],
    afterChange: [handlePublishing],
  },
}
```

## Additional Context

**Hook Types:**
- `beforeChange` - Transform data before saving
- `afterChange` - Handle side effects after saving
- `beforeRead` - Transform data before returning to client
- `afterRead` - Post-process read data
- `beforeDelete` - Validate delete operations
- `afterDelete` - Cleanup after deletion

**Hook Arguments:**
- `data` - The data being operated on
- `doc` - The document (for update/delete operations)
- `req` - Request object with user info
- `operation` - The operation type ('create', 'update', 'delete')
- `previousDoc` - Previous document state (for updates)

**Best Practices:**
- Keep hooks focused and single-purpose
- Extract complex logic into utility functions
- Use async/await for external API calls
- Handle errors appropriately in hooks
- Test hooks thoroughly
- Document hook side effects
- Consider performance impact of complex hooks